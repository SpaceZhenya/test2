<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ping Pong Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            background: #000;
            overflow:  hidden;
            font-family: Arial, sans-serif;
        }

        #gameContainer {
            width: 100%;
            height:  100%;
        }

        . ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            z-index: 10;
        }

        .scoreboard {
            display: flex;
            justify-content: space-around;
            width: 100%;
            color: #00ff00;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 10px #00ff00;
        }

        . score-item {
            text-align: center;
        }

        .score-label {
            font-size: 16px;
            margin-bottom:  10px;
            opacity: 0.8;
        }

        .score-value {
            font-size: 48px;
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
        }

        .game-status {
            text-align: center;
            color: #ffff00;
            font-size: 28px;
            font-weight: bold;
            text-shadow: 0 0 10px #ffff00;
            min-height: 40px;
        }

        . instructions {
            text-align:  center;
            color: #00ccff;
            font-size:  14px;
            text-shadow: 0 0 10px #00ccff;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ccff;
        }

        . center-info {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-grow: 1;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>

    <div class="ui-overlay">
        <div class="scoreboard">
            <div class="score-item">
                <div class="score-label">PLAYER</div>
                <div class="score-value" id="playerScore">0</div>
            </div>
            <div class="center-info">
                <div class="game-status" id="gameStatus"></div>
            </div>
            <div class="score-item">
                <div class="score-label">COMPUTER</div>
                <div class="score-value" id="computerScore">0</div>
            </div>
        </div>

        <div class="instructions">
            <p><strong>ðŸŽ® 3D PING PONG</strong></p>
            <p>Use <strong>MOUSE</strong> or <strong>ARROW KEYS â†‘â†“</strong> to move your paddle</p>
            <p>First to <strong>5 points</strong> wins!</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        console.log("Script started");

        // Wait for Three.js to load
        function checkThreeJS() {
            if (typeof THREE === 'undefined') {
                console.log("THREE not loaded yet, retrying...");
                setTimeout(checkThreeJS, 100);
                return;
            }

            console.log("THREE loaded successfully");
            startGame();
        }

        checkThreeJS();

        function startGame() {
            console.log("Starting game...");

            // Scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera. position.z = 50;
            camera.position.y = 15;

            // Renderer
            const container = document.getElementById('gameContainer');
            const renderer = new THREE. WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer. shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            console.log("Renderer created");

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 1);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(20, 30, 20);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            console. log("Lights added");

            // Create Table
            const tableGeo = new THREE.BoxGeometry(80, 1, 40);
            const tableMat = new THREE.MeshLambertMaterial({ color: 0x004400 });
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.y = -2;
            scene.add(table);

            // Create Walls
            const wallGeo = new THREE.BoxGeometry(80, 1, 2);
            const wallMat = new THREE.MeshLambertMaterial({ color: 0x00ff00 });

            const wall1 = new THREE.Mesh(wallGeo, wallMat);
            wall1.position. z = -21;
            scene.add(wall1);

            const wall2 = new THREE.Mesh(wallGeo, wallMat);
            wall2.position.z = 21;
            scene.add(wall2);

            // Create Center Line
            const lineGeo = new THREE.BoxGeometry(2, 1, 40);
            const lineMat = new THREE.MeshLambertMaterial({ color: 0x00ff00 });
            const line = new THREE.Mesh(lineGeo, lineMat);
            scene.add(line);

            // Create Paddles
            const paddleGeo = new THREE.BoxGeometry(2, 1, 10);
            const padMat1 = new THREE.MeshLambertMaterial({ color: 0xff0080 });
            const padMat2 = new THREE.MeshLambertMaterial({ color:  0x0080ff });

            const paddleLeft = new THREE.Mesh(paddleGeo, padMat1);
            paddleLeft.position.x = -38;
            scene.add(paddleLeft);

            const paddleRight = new THREE.Mesh(paddleGeo, padMat2);
            paddleRight. position.x = 38;
            scene.add(paddleRight);

            // Create Ball
            const ballGeo = new THREE. SphereGeometry(1, 32, 32);
            const ballMat = new THREE.MeshLambertMaterial({ color:  0xffff00 });
            const ball = new THREE. Mesh(ballGeo, ballMat);
            scene.add(ball);

            console.log("Game objects created");

            // Game State
            const state = {
                ballX: 0,
                ballY: 0,
                ballZ: 0,
                ballVelX: 0.5,
                ballVelZ: 0.3,
                paddleLeftZ: 0,
                paddleRightZ: 0,
                playerScore: 0,
                computerScore: 0,
                gameActive: true,
                mouseY: 0,
                upPressed: false,
                downPressed: false
            };

            // Input
            document.addEventListener('mousemove', (e) => {
                state.mouseY = (e.clientY / window.innerHeight) * 40 - 20;
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowUp') state.upPressed = true;
                if (e.key === 'ArrowDown') state.downPressed = true;
            });

            document.addEventListener('keyup', (e) => {
                if (e.key === 'ArrowUp') state.upPressed = false;
                if (e.key === 'ArrowDown') state.downPressed = false;
            });

            // Game Loop
            function animate() {
                requestAnimationFrame(animate);

                if (state.gameActive) {
                    // Update left paddle
                    let targetZ = state.mouseY;
                    if (state.upPressed) targetZ -= 2;
                    if (state. downPressed) targetZ += 2;
                    state.paddleLeftZ += (targetZ - state.paddleLeftZ) * 0.1;
                    state.paddleLeftZ = Math.max(-15, Math.min(15, state.paddleLeftZ));
                    paddleLeft.position.z = state.paddleLeftZ;

                    // Update right paddle (AI)
                    let targetAI = 0;
                    if (state.ballVelX > 0) {
                        targetAI = state.ballZ;
                        state.paddleRightZ += (targetAI - state.paddleRightZ) * 0.08;
                    } else {
                        state.paddleRightZ += (0 - state.paddleRightZ) * 0.05;
                    }
                    state.paddleRightZ = Math.max(-15, Math. min(15, state.paddleRightZ));
                    paddleRight.position.z = state.paddleRightZ;

                    // Update ball
                    state.ballX += state.ballVelX;
                    state.ballZ += state.ballVelZ;

                    // Wall collision
                    if (state.ballZ <= -20 || state.ballZ >= 20) {
                        state. ballVelZ = -state. ballVelZ;
                        state.ballZ = state.ballZ <= -20 ? -20 : 20;
                    }

                    // Left paddle collision
                    if (state.ballVelX < 0 && state.ballX <= -37 && 
                        state.ballZ >= state.paddleLeftZ - 5 && 
                        state.ballZ <= state.paddleLeftZ + 5) {
                        state.ballVelX = -state.ballVelX;
                        state.ballX = -37;
                        state.ballVelZ += (state.paddleLeftZ - state.ballZ) * 0.1;
                        state.ballVelX *= 1.05;
                    }

                    // Right paddle collision
                    if (state. ballVelX > 0 && state.ballX >= 37 && 
                        state. ballZ >= state.paddleRightZ - 5 && 
                        state.ballZ <= state.paddleRightZ + 5) {
                        state.ballVelX = -state.ballVelX;
                        state.ballX = 37;
                        state.ballVelZ += (state.paddleRightZ - state.ballZ) * 0.1;
                        state.ballVelX *= 1.05;
                    }

                    // Scoring
                    if (state. ballX < -50) {
                        state. computerScore++;
                        state.ballX = 0;
                        state.ballZ = 0;
                        state.ballVelX = 0.5;
                        state. ballVelZ = (Math.random() - 0.5) * 0.4;
                        if (state.computerScore >= 5) {
                            state. gameActive = false;
                            document.getElementById('gameStatus').textContent = 'COMPUTER WINS!  ðŸ¤– Press F5 to reload';
                        }
                    }

                    if (state.ballX > 50) {
                        state.playerScore++;
                        state.ballX = 0;
                        state.ballZ = 0;
                        state.ballVelX = -0.5;
                        state.ballVelZ = (Math.random() - 0.5) * 0.4;
                        if (state.playerScore >= 5) {
                            state.gameActive = false;
                            document.getElementById('gameStatus').textContent = 'YOU WIN! ðŸŽ‰ Press F5 to reload';
                        }
                    }

                    // Speed damping
                    if (Math.abs(state.ballVelZ) > 1) {
                        state. ballVelZ *= 0.98;
                    }

                    // Update positions
                    ball.position.set(state.ballX, state. ballY, state.ballZ);

                    // Update UI
                    document.getElementById('playerScore').textContent = state.playerScore;
                    document.getElementById('computerScore').textContent = state.computerScore;
                }

                renderer.render(scene, camera);
            }

            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window. innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            console.log("Starting animation loop");
            animate();
        }
    </script>
</body>
</html>
